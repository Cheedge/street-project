# Devevlopment Notes

## 1. Architecture

### 1.1 Backend

The basic structure of the backend, we will follow the DDD+CQRS,
and use feature/resource dominant sturcture, which will be more
clear, easy maintainable, extendable.

```
/Common
  - Interfaces
    - IQuery
    - IQueryHandler
    - ICommand
    - ICommandHandler
/Resources
  - Street
    /Domain
    - StreetDomain
    - Geometry
    - Coordinate
    /Application
    - Commands: CreateStreet, AddPoint, DeletePoint, DeleteStreet
    - CommandHandlers
    - Queries: GetStreet, GetPoint, GetAllStreets
    - QueryHandlers
    /Infrastructure
    - Context
    - Repository
    - Entities
        - StreetEntity:
    - Mappers
        - StreetEntityAndStreetDomainMapper
        - StreetDomainAndStreetDtoMapper
    /API
    - Controllers
    - DTOs
        - StreetDto
```

## 2. Tech Stacks

1. Frontend: simple Html/Css/Js or React
2. Backend: .net core, EF
3. DataBase: Postgres + PostGis
4. CICD: GitHub Action
5. Deploy: AWS 1 VPC - 2 subnet(1 public, 1 private)
    - Elastic Beanstalk(Docker)/EC2 backend code (pub subnet)
    - S3 frontend code (pub subnet)
    - RDS Postgres (privare subnet)
6. Security: IAM

## 3. Test Cases

### 3.1 Frontend

1. show streets
2. can add/delete point from one street
3. can locate one street

### 3.2 Backend

Accordng to the requiremnet, backend should basically realise:

1. When sending GET streets request, Then get all items
2. When sending GET street request, Where the Id/Geometry has limited, Then get the corresponding items
3. When sending POST point to a street request, Where street exist, Then add a point to a street
4. When sending POST street request, Then add a new street
5. When sending DELET street request, Where the street exist, Then remove the record
6. When sending DELET point of a street request, Where the street exist, Then remove the point.

## 4. Key Issue

### 4.1 Handling Concurrency Conflicts

[Handling Concurrency Conflicts](https://learn.microsoft.com/en-us/ef/core/saving/concurrency?tabs=fluent-api)

1. concurrency token
    - byte[] rowVersion/timestamp
    - Guid rowVersion
2. lock

### 4.2 NetTopologySuite

using NetTopologySuite.Geometries.Coordinate is more competable with PostGis
but some point need to be careful:

1. NetTopologySuite.Geometries.Coordinate(Y, X)

### 4.3 DB related

1. use docker Postgres+PostGis
    - `docker run --name some-postgis -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgis/postgis`
2. migration is same as using MS SQL Server

    - two pack

        - `dotnet add package Microsoft.EntityFrameworkCore.Design`
        - `dotnet add package Microsoft.EntityFrameworkCore.Tools`

    - cmd
        - initial: `dotnet ef migrations add InitialCreate --project StreetBackend`
        - apply/update: `dotnet ef database update --project StreetBackend`

3. Code First

```c#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<StreetEntity>()
        .ToTable("Streets", schema: "streetschema"); // default schema is "public"
}
```

4. Postgres

```SQL
-- Log into PostgreSQL
psql -h localhost -U postgres

-- List schemas
\dn

-- List tables in 'public' schema
\dt public.*

-- View table definition
\d public."Streets"
```

## 5. Daily

Receiving the email at June 11, start at June 13
Sumbit (should be) June 17.
In total 5 days for work.

-   Day1: (13, Fri)
    -   Basic structure design
    -   DB design
    -   Test cases
    -   Tools choose
    -   Basic implementation
-   Day2: (14, Sat)
    -   Backend implementation
    -   Database Migration
-   Day3: (15, Sun)
    -   Frontend Implementation
-   Day4: (16, Mon)
    -   Integration
    -   CICD (github and AWS)
    -   online (cloudflare)
-   Day5: (17, Thu)
    -   check and submit
